package fusionkey.lowkey.queue;

import android.app.Activity;
import android.util.Log;

import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.RetryPolicy;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.JsonObjectRequest;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.Map;

import fusionkey.lowkey.auth.models.UserDB;

import static fusionkey.lowkey.LowKeyApplication.requestQueueSingleton;

/**
 * @author Iusztin Paul
 * @version 1.0
 * @since 31.07.2018
 * <p>
 * <h1>Class that wraps the Queue API hosted in AWS</h1>
 * <h2>It uses lambda functions and Redis ElastiCache as backend</h2>
 * <p>
 * <p>The requests are make with Volley</p>
 */

public class QueueMatcherSpeakerFinder extends QueueMatcherUtils implements IQueueMatcher {

    private boolean hasStep0Response = false;

    public QueueMatcherSpeakerFinder(UserDB currentUser, Activity currentActivity) {
        super(currentUser, currentActivity);
    }

    /**
     * This method first makes a POST to add the listener to the queue and create a new lobby.
     * After it waits for speakers to come to the lobby checking with a GET method in the aws cache.
     * When the lobby it's full the speakers are returned in a container hosted by the
     * LobbyCheckerRunnable class that wraps the request and response.
     */
    @Override
    public void find() {
        HashMap<String, String> queryParameters = new HashMap<>();
        queryParameters.put(USER_API_QUERY_STRING, currentUser.getUserEmail());
        String url = getAbsoluteUrlWithQueryString(queryParameters, LISTENER_RELATIVE_URL);

        findRunnable = new LobbyCheckerRunnable(url, currentUser.getUserEmail(), null);

        // Call L0 lambda function
        JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.POST, url, null,
                new Response.Listener<JSONObject>() {

                    @Override
                    public void onResponse(JSONObject response) {
                        Log.e("findSpeakers", response.toString());
                        if (isListenerAlreadyInQueue(response)) {
                            findRunnable.makeListenerDeleteRequest();
                        } else {
                            if (responseHasData(response))
                                currentActivity.runOnUiThread(new Runnable() {
                                    @Override
                                    public void run() {
                                        new Thread(findRunnable).start();
                                    }
                                });
                        }

                        hasStep0Response = true;
                    }
                },
                new Response.ErrorListener() {
                    @Override
                    public void onErrorResponse(VolleyError error) {
                        Log.e("findSpeakerError", error.toString());
                        if (findRunnable != null) {
                            findRunnable.setResponseContainer(JSON_FAILED_REQUESTED_OBJECT);
                            findRunnable.setStillChecking(false);
                            findRunnable.makeListenerDeleteRequest();
                        }

                        hasStep0Response = true;
                    }
                }) {

            @Override
            public Map<String, String> getHeaders() {
                HashMap<String, String> headers = new HashMap<String, String>();
                headers.put("Content-Type", "application/json");

                return headers;
            }
        };

        jsonObjectRequest.setRetryPolicy(new RetryPolicy() {
            @Override
            public int getCurrentTimeout() {
                return 50000;
            }

            @Override
            public int getCurrentRetryCount() {
                return 50000;
            }

            @Override
            public void retry(VolleyError error) throws VolleyError {
                Log.e("retryVolley", error.getMessage());
            }
        });

        requestQueueSingleton.addToRequestQueue(jsonObjectRequest);
    }

    /**
     * @return the container generated by the findSpeakers() method. It returns null if there is
     * no container.
     */
    @Override
    public JSONObject getContainer() {
        if (findRunnable == null || findRunnable.isStillChecking())
            return JSON_FAILED_REQUESTED_OBJECT;

        return findRunnable.getResponseContainer();
    }

    /**
     * This method removes the lobby of the listener and ads a flag that the listener from the queue
     * it's deprecated. So no more speakers will stay or be added in the lobby for that listener.
     */

    @Override
    public void stopFinding() {
        if (findRunnable != null)
            if (findRunnable.isStillChecking())
                findRunnable.setStillChecking(false);
            else
                findRunnable.makeListenerDeleteRequest();
    }

    @Override
    public boolean hasStep0Response() {
        return hasStep0Response;
    }

    /**
     * @return the state of the loop from the thread -> if it runs or not
     */
    public boolean isLoopCheckerAlive() {
        return findRunnable != null && findRunnable.isStillChecking();
    }

    /**
     * @return loop count down from the thread to feed a progress bar
     */
    public int getLoopState() {
        if (findRunnable == null)
            return 0;

        return findRunnable.getLoopState();
    }

    public boolean isListenerAlreadyInQueue(JSONObject response) {
        try {
            int statusCode = response.getInt(STATUS_CODE_JSON_KEY);
            if (statusCode == 500)
                return true;

            String errorMessage = response.getString(ERROR_JSON_KEY);
            if (errorMessage.equals("Listener already added. Has a lobby and in queue."))
                return true;

        } catch (JSONException e) {
            return false;
        }
        return false;
    }
}
