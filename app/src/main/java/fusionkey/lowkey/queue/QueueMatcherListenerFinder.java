package fusionkey.lowkey.queue;

import android.app.Activity;
import android.util.Log;

import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.RetryPolicy;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.JsonObjectRequest;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.Map;

import fusionkey.lowkey.auth.models.UserDB;

import static fusionkey.lowkey.LowKeyApplication.requestQueueSingleton;

/**
 * @author Iusztin Paul
 * @version 1.0
 * @since 31.07.2018
 * <p>
 * <h1>Class that wraps the Queue API hosted in AWS</h1>
 * <h2>It uses lambda functions and Redis ElastiCache as backend</h2>
 * <p>
 * <p>The requests are make with Volley</p>
 */

public class QueueMatcherListenerFinder extends QueueMatcherUtils implements IQueueMatcher {

    private boolean hasStep0Response = false;

    public QueueMatcherListenerFinder(UserDB currentUser, Activity currentActivity) {
        super(currentUser, currentActivity);
    }

    /**
     * This method firstly POST the speaker in a queue and binds to a listeners queue.
     * After it checks with a GET method if the lobby is full. When the lobby is full it
     * returns all the speakers from the lobby. The listener, currentSpeaker, request and response
     * are wrapped withing the LobbyCheckerRunnable class.
     */
    @Override
    public void find() { // as a speaker
        HashMap<String, String> queryParameters = new HashMap<>();
        queryParameters.put(USER_API_QUERY_STRING, currentUser.getUserEmail());
        String url = getAbsoluteUrlWithQueryString(queryParameters, SEAPKER_RELATIVE_URL);

        // call S0 lambda function
        JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.POST, url, null,
                new Response.Listener<JSONObject>() {

                    @Override
                    public void onResponse(final JSONObject response) {
                        Log.e("findListener", response.toString());

                        if (responseHasData(response)) {
                            currentActivity.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    findRunnable = createRunnable(response);
                                    new Thread(findRunnable).start();
                                }
                            });
                        }

                        hasStep0Response = true;
                    }
                },
                new Response.ErrorListener() {
                    @Override
                    public void onErrorResponse(VolleyError error) {
                        Log.e("findSpeakerError", error.toString());
                        if (findRunnable != null) {
                            findRunnable.setResponseContainer(JSON_FAILED_REQUESTED_OBJECT);
                            findRunnable.setStillChecking(false);
                        }

                        hasStep0Response = true;
                    }

                }) {

            @Override
            public Map<String, String> getHeaders() {
                HashMap<String, String> headers = new HashMap<String, String>();
                headers.put("Content-Type", "application/json");

                return headers;
            }
        };

        jsonObjectRequest.setRetryPolicy(new RetryPolicy() {
            @Override
            public int getCurrentTimeout() {
                return 50000;
            }

            @Override
            public int getCurrentRetryCount() {
                return 50000;
            }

            @Override
            public void retry(VolleyError error) throws VolleyError {
                Log.e("retryVolley", error.getMessage());
            }
        });

        requestQueueSingleton.addToRequestQueue(jsonObjectRequest);
    }

    /**
     * @return the container generated by the findListener() method. It returns null if there is
     * no container.
     */
    @Override
    public JSONObject getContainer() {
        if (findRunnable == null || findRunnable.isStillChecking())
            return JSON_FAILED_REQUESTED_OBJECT;

        return findRunnable.getResponseContainer();
    }

    /**
     * This method removes the speaker from the lobby and adds the listener back to the queue.
     */
    @Override
    public void stopFinding() {
        if (findRunnable != null)
            if (findRunnable.isStillChecking())
                findRunnable.setStillChecking(false);
            else
                findRunnable.makeSpeakerDeleteRequest();
    }

    @Override
    public boolean hasStep0Response() {
        return hasStep0Response;
    }

    /**
     * @return the state of the loop from the thread -> if it runs or not
     */
    public boolean isLoopCheckerAlive() {
        return findRunnable != null && findRunnable.isStillChecking();
    }

    /**
     * @return loop count down from the thread to feed a progress bar
     */
    public int getLoopState() {
        if (findRunnable == null)
            return 0;

        return findRunnable.getLoopState();
    }

    private LobbyCheckerRunnable createRunnable(JSONObject response) {
        try {
            final String listener = response.get(DATA_JSON_KEY).toString();

            HashMap<String, String> queryParameters = new HashMap<>();
            queryParameters.put(USER_API_QUERY_STRING, currentUser.getUserEmail());
            queryParameters.put(LISTENER_API_QUERY_STRING, listener);

            String newUrl = getAbsoluteUrlWithQueryString(queryParameters, SEAPKER_RELATIVE_URL);
            return new LobbyCheckerRunnable(newUrl, listener, currentUser.getUserEmail());
        } catch (JSONException e) {
            Log.e("createRunnableUrl", e.getMessage());
            return null;
        }
    }
}
